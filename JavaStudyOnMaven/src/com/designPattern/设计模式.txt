创建模式


1.工厂方法模式（Factory Method）
多态性工厂模式，创建一个产品的工厂接口，把实际的工作转移到具体的子类。
	


2.抽象工厂模式（Abstract Factory）
针对多个产品等级的情况，而工厂方法模式针对单一产品等级的情况。


3.单例模式（Singleton）
系统中只有一个实例，因此构造方法应该为私有
饿汉式：类加载时直接创建静态实例
懒汉式：第一次需要时才创建一个实例，那么newInstance方法要加同步
饿汉式比懒汉式要好，尽管资源利用率要差。但是不用同步。


4.建造模式（Builder）
将一个对象的内部表象和建造过程分割，一个建造过程可以造出不同表象的对象。可简化为模版方法模式.


5.原型模式（ProtoType）
通过一个原型对象来创建一个新对象（克隆）。Java中要给出Clonable接口的实现，具体类要实现这个接口，并给出clone()方法的实现细节，这就是简单原型模式的应用。
浅拷贝：只拷贝简单属性的值和对象属性的地址
深拷贝：拷贝本对象引用的对象，有可能会出现循环引用的情况。可以用串行化解决深拷贝。写到流里再读出来，这时会是一个对象的深拷贝结果。
结构模式
如何把简单的类根据某种结构组装为大的系统


6.适配器模式（Adapter）
用一个适配器类把一个接口转成另一个接口。


7.组合模式（Composite）
把整体和局部的关系用树状结构描述出来，使得客户端把整体对象和局部对象同等看待。


8.装饰模式（Decorator）
以对客户透明的方式来扩展对象的功能。
用户根据功能需求随意选取组成对象的成分，通过方法的链式调用来实现。
可以给对象动态的增加功能，比继承灵活性更大。


9.代理模式（Proxy）
用一个代理对象来作为另一个对象的代理，对客户来说是透明的。
存在一个抽象主题类，具体主题类和代理主题类都继承（实现）抽象主题，代理主题类中的方法会调用具体主题类中相对应的方法。


10.享元模式（Flyweight Pattern）
对象的状态分为内蕴状态和外蕴状态。内蕴状态不随环境变化而变化，因此可以作成系统共享.


11.门面模式（Facade）
访问子系统的时候，通过一个Façade对象访问。Facade类是单例的。
客户代码只需要和门面对象通信，不需要和具体子系统内部的对象通信，使得他们之间的耦合关系减弱。


12.桥梁模式（Bridge）
将抽象和实现脱耦，使得二者可以单独变化。使得一个继承关系不承担两个变化因素.使用合成来代替继承的一种体现.
行为模式
描述如何在对象之间划分责任


13.策略模式（Strategy）
如同LayoutManager和具体的布局管理器的关系，在抽象策略类中定义方法，在具体策略子类中实现。客户代码根据不同的需要选择相应的具体类，例如电子商务中多种价格算法。
一种策略一旦选中，整个系统运行期是不变化的


14.模板方法（Template Method）
准备一个抽象类，把部分确定的逻辑定义在某些方法中，用其他抽象方法实现剩余的逻辑。不同子类对这些逻辑有不同的实现。
用法：定义多个抽象操作，定义并实现一个模板方法，将步骤放在这个具体方法里，推迟到子类实现。子类可以改变父类的可变部分，但不能改变模板方法所代表的顶级逻辑。


15.观察者模式（Observer）
多个观察者同时监听某一主题对象，这个主题对象状态发生变化时，会通知所有观察者对象，使他们自动更新自己。在低耦合的对象间完成协调。
Java中的事件模型就是一个应用。


16.迭代器模式（Iterator）
类似于集合中的Iterator，使用迭代器来统一不同集合对象的遍历方式，隐藏内部细节，用一个抽象迭代器，每个具体的集合类来实现特有的迭代器。


17.责任链（Chain of Responsibility）
多个处理器对象连成一串，请求在这条链上传递，由该处理这个请求的处理器来处理。发出请求的客户端并不知道哪个对象处理请求。


18.状态模式（State）
在对象内部状态改变时改变其行为。把所研究的对象的行为封装在不同的状态对象中。


19.备忘录模式（Memento）
备忘录对象用来存储另一个对象的快照对象，保存其内部状态，使得可以随时恢复。
备忘录角色：保存发起人对象的内部状态，保护内容不被除发起人对象之外的对象获取。窄接口：负责人对象和其他对象看到的接口，只允许把备忘录对象传给其他对象。宽接口：发起人能看到的接口，允许读取内部状态。
发起人角色：创建并使用备忘录对象来保存其状态
负责人角色：负责保存备忘录对象。
白箱实现：备忘录类对其他类也可见，这样发起人的状态可能会存在安全问题。
黑箱实现：把备忘录类作成发起人的内部类，对外提供一个标识接口